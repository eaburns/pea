Import "assert"
Import "basic"

// A mutual exclusion lock.
Type mutex := _mutex

// Blocks until the mutex is available and then locks the mutex.
// If the mutex is already locked by the current thread, lock panics.
Func lock:(mu mutex) { lock(mu) }

// Unlocks the mutex.
// If the mutex is not locked by the current thread, unlock panics.
Func unlock:(mu mutex) { unlock(mu) }

test lock_unlock {
	mu := mutex(),
	lock(mu),
	unlock(mu)
}

test new_thread {
	passed := false,
	mu := mutex(),
	new({
		lock(mu),
		passed := true,
		unlock(mu)
	}),
	while: {
		lock(mu),
		p := passed,
		unlock(mu),
		!p
	} do: {
		// nothing
	},
	assert_true: passed
}

// A condition allows threads to wait until an event occurs.
//
// Conditions work in conjuction with a mutex.
// A thread waiting for an event that is protected by a mutex
// will lock the mutex and check for the event.
// If the event has occcurred, it can continue on.
// If the event has not occurred, the thread can call wait
// on the condition with the mutex to block and then re-check the event.
//
// Example:
//
// 	var mu := mutex :: mutex()
// 	var cond := condition :: condition()
// 	func consumer() {
// 		lock: mu,
// 		while: {!event()} do: { wait: cond with: mu },
// 		â€¦ // do the job; mu is held
// 		unlock: mu,
// 	}
// 	func producer() {
// 		produce_event(),
// 		signal: cond, // or broadcast(cond),
// 	}
// Optionally signaler can hold the mutex, if needed:
// 	func producer2() {
// 		lock:mu,
// 		produce_event(),
// 		signal: cond, // or broadcast: cond,
// 		unlock:mu,
// 	}
Type condition := _condition

// Unlocks the mutex and blocks the calling thread
// until another thread signals or broadcast the condition,
// at which time waiting thread unblocks, re-acquires the mutex,
// and wait returns.
Func wait:with:(cond condition, mu mutex) { wait(cond, mu) }

// Wakes up a single thread that is waiting.
Func signal:(cond condition) { signal(cond) }

// Wakes up all threads that are waiting.
Func broadcast:(cond condition) { broadcast(cond) }

test cond_wait_signal {
	passed := false,
	mu := mutex(),
	cond := condition(),
	new({
		lock(mu),
		passed := true,
		signal(cond),
		unlock(mu)
	}),
	lock(mu),
	while: { !passed } do: { wait(cond, mu) },
	assert_true: passed
}

test cond_wait_broadcast {
	passed := false,
	mu := mutex(),
	cond := condition(),
	new({
		lock(mu),
		passed := true,
		broadcast(cond),
		unlock(mu)
	}),
	lock(mu),
	while: { !passed } do: { wait(cond, mu) },
	assert_true: passed
}
