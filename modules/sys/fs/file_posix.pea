Import "basic"
import "//sys/io"
import "fs"
import "io"
import "sys/internal"

// These functions return the flags for open.
// The values of the constants are not standardized,
// so we use functions to return the value from C.
func posix_o_rdonly() int32
func posix_o_wronly() int32
func posix_o_rdwr() int32
func posix_o_append() int32
func posix_o_create() int32
func posix_o_trunc() int32
func posix_o_excl() int32

// These are the C routines for file operations.
// Negative integer returns are negative errno values.
// These functions handle EINTR, so it will never be returned.
func posix_open(path string, flags int32, perm int32) int32
func posix_unlink(path string) int32
// returns the directory pointer by the dir argument on success.
func posix_fdopendir(fd sys#io#descriptor, dir &dir) int32
func posix_closedir(dir dir) int32
// returns 0 and an empty name on end-of-directory
func posix_readdir(dir dir, name &[uint8]) int32
func posix_mkdir(path string, perm int32) int32
func posix_rmdir(path string) int32

type _file &[
	.fd sys#io#descriptor,
	.dir dir option,
]

type dir &int

// Opens a file at a local filesystem path with given options.
Func open(path string, opts open_options) file fs#open_result {
	flags := int32 :: 0,
	if: opts.read && opts.write then: {
		flags := posix_o_rdwr()
	} else: {
		if: opts.read then: {
			flags := posix_o_rdonly()
		},
		if: opts.write then: {
			flags := posix_o_wronly()
		}
	},
	if: opts.create then: {
		flags := flags | posix_o_create()
	},
	if: opts.truncate then: {
		flags := flags | posix_o_trunc()
	},
	if: opts.exclusive then: {
		flags := flags | posix_o_excl()
	},
	perms := int32 :: opts.permissions,
	fd := posix_open(path, flags, perms),
	if: fd = -internal#eexist() then: {
		return: [exists? internal#errno_error(-fd)]
	},
	if: fd = -internal#enoent() then: {
		err := internal#errno_error(-fd),
		return: [does_not_exist? err]
	},
	if: fd = -internal#eacces() then: {
		return: [permission_denied? internal#errno_error(-fd)]
	},
	if: fd < 0 then: {
		return: [unknown_error? internal#errno_error(-fd)]
	},
	return: [ok? [.fd sys#io#descriptor :: fd, .dir none()]]
}

// Removes a file or empty directory
// at a path in the local filesystem.
Func remove(path string) error option {
	r0 := posix_unlink(path),
	if: r0 = 0 then: {
		return: none()
	},
	r1 := posix_rmdir(path),
	if: r1 = 0 then: {
		return: none()
	},
	// rmdir will return ENOTDIR on both osx and Linux if the file is not a directory.
	// In that case, unlink was intended, so return the error from unlink.
	// Otherwise, rmdir was intended, so return the error from rmdir.
	// See: https://golang.org/src/os/file_unix.go?s=9160:9190#L312.
	if: r1 = -internal#enotdir() then: {
		return: some(internal#errno_error(-r0))
	},
	return: some(internal#errno_error(-r1))
}

// Returns the file's descriptor.
Func descriptor(f file) sys#io#descriptor { return: f.fd }

// Closes an open file.
// An error is returned if called on an already closed file.
Func close(f file) error option {
	return: close(descriptor(f))
}

// Reads at most buf.length bytes from an open file into buf.
Func read(f file, buf [uint8]) io#read_result {
	return: read(descriptor(f), buf)
}

// Writes at most buf.length bytes from buf to an open file.
// If fewer than buf.length bytes are written,
// a non-none error is returned.
Func write(f file, buf [uint8]) io#write_result {
	return: write(descriptor(f), buf)
}

Func read_dir(f file) fs#read_dir_result {
	dir := f.dir some? (d dir) {
		d
	} none? {
		d := dir :: 0,
	 	res := posix_fdopendir(f.fd, d),
	 	if: res < 0 then: {
	 		return: [error? internal#errno_error(-res)]
	 	},
	 	f.dir := some(d),
	 	d
	},
	ent := "",
	while: {ent = "" || ent = "." || ent = ".."} do: {
		buf := [uint8] :: [],
		res := posix_readdir(dir, buf),
		if: res < 0 then: {
			return: [error? internal#errno_error(-res)]
		},
		if: buf.length = 0 then: {
			return: [eof?]
		},
		ent := string:: buf
	},
	return: [ok? ent]
}

Func mkdir(path string, perm int32) error option {
	res := posix_mkdir(path, perm),
	if: res = 0 then: {
		return: none()
	},
	return: some(internal#errno_error(-res))
}
