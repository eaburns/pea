Import "basic"
import "//sys/io"
import "io"
import "sys/internal"

func o_rdonly() int32
func o_wronly() int32
func o_rdwr() int32
func o_append() int32
func o_create() int32
func o_trunc() int32
func o_excl() int32
func o_directory() int32

func fstat(fd int32, is_dir &int32)int32
func open(path string, flags int32, perm int32) int32
func unlink(path string) int32
func fdopendir(fd int32, dir &DIR) int32
func closedir(dir DIR) int32
// returns 0 and an empty name on end-of-directory
func readdir(dir DIR, name &[uint8]) int32
func mkdir(path string, perm int32) int32
func rmdir(path string) int32

func open_result_error(errno int32) T open_result {
	if: errno = internal#eexist() then: {
		return: [exists? internal#errno_error(errno)]
	},
	if: errno = internal#enoent() then: {
		return: [does_not_exist? internal#errno_error(errno)]
	},
	if: errno = internal#eacces() then: {
		return: [permission_denied? internal#errno_error(errno)]
	},
	if: errno = internal#eisdir() then: {
		return: [is_directory? internal#errno_error(errno)]
	},
	if: errno = internal#enotdir() then: {
		return: [not_directory? internal#errno_error(errno)]
	},
	return: [unknown_error? internal#errno_error(errno)]
}

func open_options_flags(opts open_options) int32 {
	flags := int32 :: 0,
	if: opts.read && opts.write then: {
		flags := o_rdwr()
	} else: {
		if: opts.read then: {
			flags := o_rdonly()
		},
		if: opts.write then: {
			flags := o_wronly()
		}
	},
	if: opts.create then: {
		flags := flags | o_create()
	},
	if: opts.truncate then: {
		flags := flags | o_trunc()
	},
	if: opts.exclusive then: {
		flags := flags | o_excl()
	},
	return: flags
}

// Opens an entry at a local file system path for read only.
Func open(path string) entry open_result {
	fd := open(path, o_rdonly(), 0),
	if: fd < 0 then: {
		return: open_result_error(-fd)
	},
	is_dir := int32 :: 0,
	stat_result := fstat(fd, is_dir),
	if: stat_result < 0 then: {
		return: open_result_error(-stat_result)
	},
	if: is_dir = 0 then: {
		return: [ok? [file? file :: fd]]
	},
	dir := DIR :: 0,
	res := fdopendir(fd, dir),
	if: res < 0 then: {
		return: open_result_error(-res)
	},
	return: [ok? [dir? [.fd internal#descriptor :: fd, .dir dir]]]
}

type _file  sys#io#descriptor

// Opens a file at a local file system path with given options.
Func open_file(path string, opts open_options) file open_result {
	flags := open_options_flags(opts),
	perms := int32 :: opts.permissions,
	fd := open(path, flags, perms),
	if: fd < 0 then: {
		return: open_result_error(-fd)
	},
	return: [ok? file :: fd]
}

// Returns the file's descriptor.
Func descriptor(f file) sys#io#descriptor { return: sys#io#descriptor :: f }

// Closes an open file.
// An error is returned if called on an already closed file.
Func close(f file) error option {
	return: close(descriptor(f))
}

// Reads at most buf.length bytes from an open file into buf.
Func read(f file, buf [uint8]) io#read_result {
	return: read(descriptor(f), buf)
}

// Writes at most buf.length bytes from buf to an open file.
// If fewer than buf.length bytes are written,
// a non-none error is returned.
Func write(f file, buf [uint8]) io#write_result {
	return: write(descriptor(f), buf)
}

type _dir [
	.fd internal#descriptor,
	.dir &DIR,
]

// DIR is to be treated as an opaque address.
// TODO: make DIR be &[.] once flowgraph crash is fixed.
type DIR &int

// Opens a directory for reading.
Func open_dir(path string) dir open_result {
	flags := o_directory() | o_rdonly(),
	fd := open(path, flags, 0),
	if: fd < 0 then: {
		return: open_result_error(-fd)
	},

	dir := DIR :: 0,
	res := fdopendir(fd, dir),
	if: res < 0 then: {
		return: open_result_error(-res)
	},
	return: [ok? [.fd internal#descriptor :: fd, .dir dir]]
}

// Closes an open directory.
Func close(d dir) error option {
	res := closedir(d.dir),
	if: res < 0 then: {
		return: some(internal#errno_error(-res))
	},
	return: none()
}

// Reads the next entry from a directory.
Func read_dir(d dir) read_dir_result {
	ent := "",
	while: {ent = "" || ent = "." || ent = ".."} do: {
		buf := [uint8] :: [],
		res := readdir(d.dir, buf),
		if: res < 0 then: {
			return: [error? internal#errno_error(-res)]
		},
		if: buf.length = 0 then: {
			return: [eof?]
		},
		ent := string:: buf
	},
	return: [ok? ent]
}

// Creates a directory with the given permissions.
Func create_dir(path string, perm int32) error option {
	res := mkdir(path, perm),
	if: res = 0 then: {
		return: none()
	},
	return: some(internal#errno_error(-res))
}

// Removes a file or empty directory
// at a path in the local file system.
Func remove(path string) error option {
	r0 := unlink(path),
	if: r0 = 0 then: {
		return: none()
	},
	r1 := rmdir(path),
	if: r1 = 0 then: {
		return: none()
	},
	// rmdir will return ENOTDIR on both osx and Linux if the file is not a directory.
	// In that case, unlink was intended, so return the error from unlink.
	// Otherwise, rmdir was intended, so return the error from rmdir.
	// See: https://golang.org/src/os/file_unix.go?s=9160:9190#L312.
	if: r1 = -internal#enotdir() then: {
		return: some(internal#errno_error(-r0))
	},
	return: some(internal#errno_error(-r1))
}
