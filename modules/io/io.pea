Import "assert"
Import "basic"
import "print"

// The result of a read operation.
//
// Various functions take a read()able paramaterized type.
// The read function should have the signature:
// 	read(r R, buf [uint8])read_result
// The returned read_result should have the following cases:
// 	ok? n	indicates n bytes were read into the beginning of buf;
// 			n is never larger than buf.length,
// 			the remainder of buf after the first n bytes
// 			should be left unmodified.
// 	end?	there were no bytes to read; the end of input was reached.
//	error? e	 an error, e, was encountered;
// 			an unspecified number of bytes may have been read.
Type read_result [
	// The given number of bytes were successfully read.
	ok? int,
	// The end of the input was reached;
	// there was nothing left to read.
	end?,
	// An error was encountered.
	error? error,
]

// The result of a write operation.
//
// Various functions take a write()able paramaterized type.
// The write function should have the signature:
// 	write(r R, buf [uint8])write_result
// The returned write_result indicates the number of bytes written,
// and whether an error occurred.
// The number of bytes written can never be greater than buf.length.
// It is an error if the number of bytes written is less than buf.length;
// implementations that may have a "short write"
// should contiunally writing until the entire buffer is written
// or return an error indicating the short write.
Type write_result [
	// The number of bytes written.
	.n int,
	// Whether there was an error.
	.error error option,
]

// Returns the number of bytes written if there was no error,
// otherwise returns the result of e called with the error.
Func error?(res write_result, e (error){int}) int {
	return: res.error none? {
		res.n
	} some? (err) {
		e(err)
	}
}

// Returns the number of bytes written;
// panics if there was an error.
Func must(res write_result) int {
	return: res error? (e){ panic(print#string(e)) }
}

// Reads until buf is full.
// It is an error if exactly buf.length bytes are not read.
Func read_full(r R, buf [uint8])error option : read(R, [uint8])read_result {
	total := 0,
	while: {total < buf.length} do: {
		read(r, buf[total, buf.length]) ok? (n){
			total += n,
		} end? {
			return: error("unexpected end-of-input")
		} error? (err) {
			return: error(err)
		},
	},
	return: none()
}

// Reads from a reader until its end
// and returns an array of all bytes read.
Func read_all(r R) [uint8] or_error : read(R, [uint8]) read_result {
	total := 0,
	buf := [uint8] :: new(128, uint8 :: 0),
	while: {true} do: {
		read(r, buf[total, buf.length]) ok? (n){
			total := total + n
		} error? (e){
			return: [error? e]
		} end? {
			return: [ok? buf[0, total]]
		},
		if: total = buf.length then: {
			buf2 := [uint8] :: new(buf.length*2, uint8 :: 0),
			for: 0 to: total do: (i) {
				buf2[i] := buf[i]
			},
			buf := buf2
		}
	},
	return: [error? new("impossible")]
}
