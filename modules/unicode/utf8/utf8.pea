Import "assert"
Import "basic"
import "print"
import "unicode"

// Calls f for each rune decoded starting at the beginning of s.
Func for:runes:(s S, f (rune){}) : .length(S)int, [](S, int)uint8, [](S, int, int)S {
	while: {decode(s)} some: (rw) {
		s := s[rw.width, s.length],
		f(rw.rune)
	},
}

test for_runes {
	i := 0,
	for: "1â˜ºâ˜¹a" runes: (r) {
		if: i = 0 then: {
			assert: r equals: '1',
		},
		if: i = 1 then: {
			assert: r equals: 'â˜º',
		},
		if: i = 2 then: {
			assert: r equals: 'â˜¹',
		},
		if: i = 3 then: {
			assert: r equals: 'a',
		},
		if: i > 3 then: {
			panic("too much")
		},
		++i
	},

	i := 0,
	for: [uint8] :: [49, 226, 152, 186, 226, 152, 185, 97] runes: (r) {
		if: i = 0 then: {
			assert: r equals: '1',
		},
		if: i = 1 then: {
			assert: r equals: 'â˜º',
		},
		if: i = 2 then: {
			assert: r equals: 'â˜¹',
		},
		if: i = 3 then: {
			assert: r equals: 'a',
		},
		if: i > 3 then: {
			panic("too much")
		},
		++i
	},
}

// Returns the first rune in the string and its byte width.
// If the string is empty, none() is returned.
// If there is any other error, the replacement character is returned and width 1.
Func decode(s S) [.rune rune, .width int] option : .length(S)int, [](S, int)uint8 {
	if: s.length < 1 then: {
		return: none()
	},
	info := rune_info(s[0]) some? (i [.width int, .mask rune, .min rune]){
		i
	} none? {
		return: some([.rune unicode#replacement, .width 1])
	},
	if: s.length < info.width then: {
		return: some([.rune unicode#replacement, .width 1])
	},
	r := (rune :: s[0]) & info.mask,
	for: 1 to: info.width-1 do: (i) {
		si := rune :: s[i],
		if: si < 0x80 || si > 0xBF then: {
			return: some([.rune unicode#replacement, .width 1])
		},
		r := (r << 6) | si&0x3F,
	},
	if: r < info.min || r > unicode#max then: {
		return: some([.rune unicode#replacement, .width 1])
	},
	return: some([.rune r, .width info.width])
}

// Returns the rune width, 0-byte mask, and min value given the 0th byte.
func rune_info(s0 uint8) [.width int, .mask rune, .min rune] option {
	if: (s0&(uint8 :: 1<<7)) = 0 then: {
		return: some([.width 1, .mask rune :: 0x7F, .min rune :: 0])
	},
	if: (s0&(uint8 :: 1<<6)) = 0 then: {
		return: none()	// 10xx xxxx are invalid.
	},
	if: (s0&(uint8 :: 1<<5)) = 0 then: {
		return: some([.width 2, .mask rune :: 0x1F, .min rune :: 0x80])
	},
	if: (s0&(uint8 :: 1<<4)) = 0 then: {
		return: some([.width 3, .mask rune :: 0xF, .min rune :: 0x800])
	},
	if: (s0&0xF8) = 0xF0 then: {
		return: some([.width 4, .mask rune :: 0x7, .min rune :: 0x10000])
	},
	return: none()
}

func +=(p print#printer, d [.rune rune, .width int]) print#printer {
	return: p += "[.rune " += d.rune += ", .width " += d.width += "]"
}

func =(a [.rune rune, .width int], b [.rune rune, .width int])bool {
	return: a.rune = b.rune && a.width = b.width
}

test decode {
	assert_none: decode(""),
	assert: decode("hello") some: [.rune 'h', .width 1],
	assert: decode("Ã¡Ã¡") some: [.rune 'Ã¡', .width 2],
	assert: decode("â˜ºâ˜¹") some: [.rune 'â˜º', .width 3],
	assert: decode("ðŸ‚¡ðŸ‚¡") some: [.rune 'ðŸ‚¡', .width 4],

	assert: decode([uint8] :: [0x0]) some: [.rune 0x0, .width 1],
	// Largest unicode codepoint.
	assert: decode([uint8] :: [0xF4, 0x8F, 0xBF, 0xBF]) some: [.rune unicode#max, .width 4],
}

test decode_errors {
	// 10xx xxxx is invalid
	assert_error: decode([uint8] :: [0x80]),
	assert_error: decode([uint8] :: [0x81]),
	assert_error: decode([uint8] :: [0x8F]),
	assert_error: decode([uint8] :: [0xB0]),
	assert_error: decode([uint8] :: [0xB1]),
	assert_error: decode([uint8] :: [0xBF]),
	assert_error: decode([uint8] :: [0x90]),
	assert_error: decode([uint8] :: [0x91]),
	assert_error: decode([uint8] :: [0x9F]),

	// Invalid continuation bytes.
	assert_error: decode([uint8] :: [0xB0, 0xFF]),
	assert_error: decode([uint8] :: [0xD0, 0xFF, 0xFF]),
	assert_error: decode([uint8] :: [0xF0, 0xFF, 0xFF, 0xFF]),

	// Missing continuation bytes.
	assert_error: decode([uint8] :: [0xB0]),
	assert_error: decode([uint8] :: [0xD0,]),
	assert_error: decode([uint8] :: [0xD0, 0xFF]),
	assert_error: decode([uint8] :: [0xF0]),
	assert_error: decode([uint8] :: [0xF0, 0xFF]),
	assert_error: decode([uint8] :: [0xF0, 0xFF, 0xFF]),

	// Too large.
	assert_error: decode([uint8] :: [0xF4, 0x9F, 0xBF, 0xBF]),

	// Bad byte 0 â€” too many 1s.
	assert_error: decode([uint8] :: [0xFF, 0x8F, 0xBF, 0xBF, 0xBF, 0xBF]),

	// Overlongs:
	// 'a' encoded in 4 bytes.
	assert_error: decode([uint8] :: [0xF0, 0x80, 0x81, 0xA1]),
	// 'a' encoded in 3 bytes.
	assert_error: decode([uint8] :: [0xE0, 0x81, 0xA1]),
	// â‚¬ (3 bytes) encoded in 4 bytes.
	assert_error: decode([uint8] :: [0xF0, 0x82, 0x82, 0xAC]),
}

func assert_error:(r [.rune rune, .width int] option) {
	assert: r some: [.rune unicode#replacement, .width 1],
}