Import "assert"
Import "basic"
import "print"

// An ordered sequence of elements of type T.
// A ring_buffer is implemented as a circular array.
// Indexing and slicing are constant time.
// Insertion and removal from the front or back are amortized constant time.
Type T ring_buffer := T _ring_buffer
type T _ring_buffer &[
	.n int,
	.start int,
	.end int, // exclusive
	.data [T],
]

// Returns a new, empty ring_buffer.
Func new() T ring_buffer {
	return: [.n 0, .start 0, .end 0, .data []]
}

test new {
	r := int ring_buffer :: new(),
	assert: r.length equals: 0
}

// Returns a new ring buffer with elements copied from ts.
Func new(ts [T]) T ring_buffer {
	return: [.n ts.length, .start 0, .end ts.length, .data copy(ts)]
}

test new_array {
	r := int ring_buffer :: new([0, 1, 2, 3]),
	assert: r.length equals: 4,
	assert: r elements: [0, 1, 2, 3]
}

test new_array_copies_array {
	a := [0, 1, 2, 3],
	r := int ring_buffer :: new(a),
	r[0] := 10,
	r[1] := 9,
	r[2] := 8,
	r[3] := 7,
	assert: a elements: [0, 1, 2, 3]
}

// Returns the number of elements in the ring_buffer.
Func .length(r T ring_buffer) int {
	return: r.n
}

// Returns a reference to the ith entry in the ring_buffer.
//
// This function panics if i is negative or
// if i is greater or equal to the length of the ring_buffer.
Func [](r T ring_buffer, i int) &T {
	if: i < 0 then: {
		panic(print#string("index out of bounds: " ++ i ++ " < 0"))
	},
	if: i >= r.n then: {
		panic(print#string("index out of bounds: " ++ i ++ " >= " ++ r.n))
	},
	return: r.data[index(r, i)]
}

test index {
	r := string ring_buffer :: new(),
	for: ["zero", "one", "two", "three", "four", "five", "six"] each: (s){
		r push_back: s
	},
	assert: r[0] equals: "zero",
	assert: r[1] equals: "one",
	assert: r[2] equals: "two",
	assert: r[3] equals: "three",
	assert: r[4] equals: "four",
	assert: r[5] equals: "five",
	assert: r[6] equals: "six"
}

// Returns a slice of the ring_buffer from start (inclusive) to end (exclusive).
// The returned slice refers to the same backing array as the sliced ring_buffer,
// but on resizing either buffer, the backing arrays will no longer remain the same.
//
// This function panics if s is negative, if s is greater than e,
// or if e is greater than the length of the ring_buffer.
Func [](r T ring_buffer, s int, e int) T ring_buffer {
	if: s < 0 then: {
		panic(print#string("start index out of bounds: " ++ s ++ " < 0"))
	},
	if: e > r.n then: {
		panic(print#string("end index out of bounds: " ++ e ++ " >= " ++ r.n))
	},
	if: s > e then: {
		panic(print#string("start index is greater than end: " ++ s ++ " > " ++ e))
	},
	return: [.n e - s, .start index(r, s), .end index(r, e), .data r.data]
}

test slice {
	r := string ring_buffer :: new(["Hello", ",", " ", "World", "!"]),
	assert: r[0, 0] elements: [string] :: [],
	assert: r[2, 2] elements: [string] :: [],
	assert: r[4, 4] elements: [string] :: [],
	assert: r[0, 1] elements: ["Hello"],
	assert: r[2, 3] elements: [" "],
	assert: r[4, 5] elements: ["!"],
	assert: r[0, 4] elements: ["Hello", ",", " ", "World"],
	assert: r[1, 5] elements: [",", " ", "World", "!"],
	assert: r[1, 4] elements: [",", " ", "World"],
	assert: r[0, 5] elements: ["Hello", ",", " ", "World", "!"]
}

// Returns the 0th element of the ring_buffer if it is not empty.
Func .front(r T ring_buffer) T option {
	return: r.n > 0 true? {
		some(r.data[index(r, 0)])
	} false? {
		none()
	}
}

test front {
	assert_none: (int ring_buffer :: new()).front,
	assert: (int ring_buffer :: new([0, 1, 2])).front some: 0
}

// Returns the (n-1th)th element of the ring_buffer if it is not empty,
// where n is the length of the ring_buffer.
Func .back(r T ring_buffer) T option {
	return: r.n > 0 true? {
		some(r.data[prev(r, r.end)])
	} false? {
		none()
	}
}

test back {
	assert_none: (int ring_buffer :: new()).back,
	assert: (int ring_buffer :: new([0, 1, 2])).back some: 2
}

// Inserts an element onto the front of the ring_buffer.
//
// This function operates in amortized constant time.
// It may cause the ring_buffer to be resized.
Func push_front:(r T ring_buffer, t T) {
	if: r.n = r.data.length then: {
		grow(r, t, 1)
	},
	r.start := prev(r, r.start),
	r.data[r.start] := t,
	++r.n
}

test push_front {
	r := int ring_buffer :: new(),
	for: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] each: (i){
		r push_front: i
	},
	assert: r elements: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
}

// Inserts an element onto the back of the ring_buffer.
//
// This function operates in amortized constant time.
// It may cause the ring_buffer to be resized.
Func push_back:(r T ring_buffer, t T) {
	if: r.n = r.data.length then: {
		grow(r, t, 1)
	},
	r.data[r.end] := t,
	r.end := next(r, r.end),
	++r.n
}

test push_back {
	r := int ring_buffer :: new(),
	for: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] each: (i){
		r push_back: i
	},
	assert: r elements: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
}

// Appends all elements of ts onto the back of the ring_buffer.
//
// It may cause the ring_buffer to be resized.
//
// This function performs the same as calling push_back:
// on each individual element of ts,
// however it may save on the number of grow operations.
Func append:(r T ring_buffer, ts C) : { .length(C)int, [](C, int)T } {
	if: ts.length = 0 then: {
		return()
	},
	if: r.n + ts.length > r.data.length then: {
		grow(r, ts[0], ts.length)
	},
	assert_true: r.n + ts.length <= r.data.length,
	r.n += ts.length,
	n := 0,
	if: r.start <= r.end then: {
		n := min(r.data.length - r.end, ts.length),
		for: 0 to: n - 1 do: (i){
			r.data[r.end] := ts[i],
			++r.end
		},
		if: n >= ts.length then: {
			return() // done
		},
		r.end := 0 // wrap
	},
	for: n to: ts.length - 1 do: (i){
		r.data[r.end] := ts[i],
		++r.end
	}
}

test append {
	r := int ring_buffer :: new(),
	r append: ([int] :: []),
	assert: r elements: [int] :: [],

	r := int ring_buffer :: new(),
	r append: [0],
	assert: r elements: [0],

	r := int ring_buffer :: new(),
	r append: [0, 1],
	assert: r elements: [0, 1],

	r := int ring_buffer :: new(),
	r append: [0, 1, 2, 3, 4],
	assert: r elements: [0, 1, 2, 3, 4],

	r := int ring_buffer :: new([0, 1, 2]),
	r append: [3, 4, 5, 6, 7],
	assert: r elements: [0, 1, 2, 3, 4, 5, 6, 7],
	r append: ([int] :: []),
	assert: r elements: [0, 1, 2, 3, 4, 5, 6, 7]
}

test append_wraps_around {
	r := int ring_buffer :: [
		.n 4,
		.start 2,
		.end 6,
		//  [] 0  1  2  3  4  5  6  7  8
		//           s           e
		.data [0, 0, 1, 2, 3, 4, 0, 0, 0]
	],
	r append: [5, 6, 7, 8, 9],
	/*
	[
		.n 9,
		.start 2
		.end 2,
		//  [] 0  1  2  3  4  5  6  7  8
		//           s
		//           e
		.data [8, 9, 1, 2, 3, 4, 5, 6, 7],
	]
	*/
	assert: r.n equals: 9,
	assert: r.start equals: 2,
	assert: r.end equals: 2,
	assert: r.data equals: [8, 9, 1, 2, 3, 4, 5, 6, 7]
}

func grow(r T ring_buffer, t T, delta int) {
	n := (r.data.length + 1)*2,
	while: { n < r.n + delta } do: {
		n *= 2
	},
	data := [T] :: new(n, t),
	start := data.length/4,
	end := start,
	assert_true: data.length - start > r.n,
	if: r.n > 0 then: {
		if: r.start < r.end then: {
			for: r.start to: r.end - 1 do: (i){
				data[end] := r.data[i],
				++end
			}
		} else: {
			for: r.start to: r.data.length - 1 do: (i){
				data[end] := r.data[i],
				++end
			},
			for: 0 to: r.end - 1 do: (i){
				data[end] := r.data[i],
				++end
			}
		}
	},
	r.start := start,
	r.end := end,
	r.data := data
}

// Removes and returns the 0th element of the ring_buffer if any.
//
// This function operates in amortized constant time.
Func pop_front(r T ring_buffer) T option {
	if: r.n = 0 then: {
		return: none()
	},
	x := r.data[index(r, 0)],
	r.start := next(r, r.start),
	--r.n,
	return: some(x)
}

test pop_front {
	r := int ring_buffer :: new(),
	assert_none: pop_front(r),

	r := new([0, 1, 2]),
	assert: pop_front(r) some: 0,
	assert: r.length equals: 2,
	assert: pop_front(r) some: 1,
	assert: r.length equals: 1,
	assert: pop_front(r) some: 2,
	assert: r.length equals: 0,
	assert_none: pop_front(r),
	assert: r.length equals: 0
}

// Removes and returns the (n-1)th element of the ring_buffer if any,
// where in is the length of the ring_buffer.
//
// This function operates in amortized constant time.
Func pop_back(r T ring_buffer) T option {
	if: r.n = 0 then: {
		return: none()
	},
	x := r.data[prev(r, r.end)],
	r.end := prev(r, r.end),
	--r.n,
	return: some(x)
}

test pop_back {
	r := int ring_buffer :: new(),
	assert_none: pop_back(r),

	r := new([0, 1, 2]),
	assert: pop_back(r) some: 2,
	assert: r.length equals: 2,
	assert: pop_back(r) some: 1,
	assert: r.length equals: 1,
	assert: pop_back(r) some: 0,
	assert: r.length equals: 0,
	assert_none: pop_back(r),
	assert: r.length equals: 0
}

test push_pop_front_back {
	r := string ring_buffer :: new(),
	r push_front: "three",
	r push_back: "four",
	r push_front: "two",
	assert: r elements: ["two", "three", "four"],
	assert: pop_back(r) some: "four",
	assert: r elements: ["two", "three"],
	r push_back: "four",
	assert: r elements: ["two", "three", "four"],
	assert: pop_front(r) some: "two",
	assert: r elements: ["three", "four"],
	r push_front: "one",
	assert: r elements: ["one", "three", "four"],
	assert: pop_back(r) some: "four",
	assert: r elements: ["one", "three"],
	assert: pop_back(r) some: "three",
	assert: r elements: ["one"],
	assert: pop_front(r) some: "one",
	assert: r elements: [string] :: [],
	assert_none: pop_front(r),
	assert: r elements: [string] :: []
}

// Calls f for each element of the ring_buffer,
// in order from the 0th to the (n-1)th,
// where in is the length of the ring_buffer.
Func for:each:(r T ring_buffer, f (T){}) {
	if: r.n = 0 then: {
		return()
	},
	if: r.start < r.end then: {
		for: r.start to: r.end - 1 do: (i){
			f(r.data[i])
		}
	} else: {
		for: r.start to: r.data.length - 1 do: (i){
			f(r.data[i])
		},
		for: 0 to: r.end - 1 do: (i){
			f(r.data[i])
		}
	}
}

func index(r T ring_buffer, i int) int {
	i += r.start,
	if: i >= r.data.length then: {
		i -= r.data.length
	},
	return: i
}

func next(r T ring_buffer, i int) int {
	++i,
	if: i >= r.data.length then: {
		i -= r.data.length
	},
	return: i
}

func prev(r T ring_buffer, i int) int {
	i := i + r.data.length - 1,
	if: i >= r.data.length then: {
		i -= r.data.length
	},
	return: i
}
