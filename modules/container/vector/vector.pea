Import "assert"
Import "basic"
import "print"

// An ordered sequence of elements of type T.
//
// A vector is implemented as an underlying array,
// possibly larger than the size of the vector,
// and a count of the number number of element in the vector.
//
// Indexing and slicing are constant time.
// Insertion and removal from the front or back are amortized constant time.
Type T vector := T _vector
type T _vector &[.n int, .data [T]]

// Returns a new, empty vector.
Func new() T vector {
	return: [.n 0, .data []]
}

test new {
	v := int vector :: new(),
	assert: v.length equals: 0,
}

// Returns a new vector with elements copied from ts.
Func new(a [T]) T vector {
	return: [.n a.length, .data copy(a)]
}

test new_array {
	v := int vector :: new([0, 1, 2, 3]),
	assert: v.length equals: 4,
	assert: v elements: [0, 1, 2, 3],
}

test new_array_copies_array {
	a := [0, 1, 2, 3],
	v := int vector :: new(a),
	v[0] := 10,
	v[1] := 9,
	v[2] := 8,
	v[3] := 7,
	assert: a equals: [0, 1, 2, 3],
}

// Returns the number of elements in the vector.
Func .length(v T vector) int {
	return: v.n
}

// Clears the vector, leaving it empty.
// Capacity in the underlying array is retained.
Func clear:(v T vector) {
	v.n := 0,
}

test clear {
	v := string vector :: new(["Hello", "World", "!"]),
	clear: v,
	assert: v.length equals: 0,
}

// Returns a reference to the ith entry in the vector.
//
// This function panics if i is negative or
// if i is greater or equal to the length of the vector.
Func [](v T vector, i int) &T {
	if: i < 0 then: {
		panic(print#string("index out of bounds: " ++ i ++ " < 0"))
	},
	if: i >= v.n then: {
		panic(print#string("index out of bounds: " ++ i ++ " >= " ++ v.n))
	},
	return: v.data[i]
}

test index {
	v := string vector :: new(["Hello", "World", "!"]),
	assert: v[0] equals: "Hello",
	assert: v[1] equals: "World",
	assert: v[2] equals: "!",
}

// Returns a slice of the vector from start (inclusive) to end (exclusive).
// The returned slice refers to the same backing array as the sliced vector,
// but on resizing either vector, the backing arrays will no longer be the same.
//
// This function panics if s is negative, if s is greater than e,
// or if e is greater than the length of the vector.
Func [](v T vector, s int, e int) T vector {
	if: s < 0 then: {
		panic(print#string("start index out of bounds: " ++ s ++ " < 0"))
	},
	if: e > v.n then: {
		panic(print#string("end index out of bounds: " ++ e ++ " >= " ++ v.n))
	},
	if: s > e then: {
		panic(print#string("start index is greater than end: " ++ s ++ " > " ++ e))
	},
	return: [.n e-s, .data v.data[s, e]]
}

test slice {
	v := string vector :: new(["Hello", ",", " ", "World", "!"]),
	assert: v[0, 0] elements: [string] :: [],
	assert: v[2, 2] elements: [string] :: [],
	assert: v[4, 4] elements: [string] :: [],
	assert: v[0, 1] elements: ["Hello"],
	assert: v[2, 3] elements: [" "],
	assert: v[4, 5] elements: ["!"],
	assert: v[0, 4] elements: ["Hello", ",", " ", "World"],
	assert: v[1, 5] elements: [",", " ", "World", "!"],
	assert: v[1, 4] elements: [",", " ", "World"],
	assert: v[0, 5] elements: ["Hello", ",", " ", "World", "!"],
}

test slice_shares_orignial_array {
	v := string vector :: new(["Hello", ",", " ", "World", "!"]),
	s := v[1, 3],
	s[0] := "---",
	assert: v elements: ["Hello", "---", " ", "World", "!"],
}

// Returns the (n-1th)th element of the vector if it is not empty,
// where n is the length of the vector.
Func .back(v T vector) &T {
	return: v[v.n-1]
}

// Inserts an element onto the back of the vector.
//
// This function operates in amortized constant time.
// It may cause the vector to be resized.
Func push_back:(v T vector, t T) {
	if: v.n >= v.data.length then: {
		data := [T] :: new((v.data.length+1) * 2, t),
		for: 0 to: v.data.length - 1 do: (i) {
			data[i] := v.data[i]
		},
		v.data := data
	},
	v.data[v.n] := t,
	++v.n
}

test push_back {
	v := int vector :: new(),
	assert: v.length equals: 0,

	v push_back: 0,
	assert: v.length equals: 1,
	assert: v elements: [0],

	v push_back: 1,
	assert: v.length equals: 2,
	assert: v elements: [0, 1],

	v push_back: 2,
	assert: v.length equals: 3,
	assert: v elements: [0, 1, 2],
}

// Removes and returns the (n-1)th element of the vector if any,
// where in is the length of the vector.
//
// This function operates in amortized constant time.
Func pop_back(v T vector) T {
	if: v.n = 0 then: {
		panic("pop_back from an empty vector")
	},
	--v.n,
	return: v.data[v.n]
}

test pop_back {
	v := int vector :: new([0, 1, 2]),

	assert: pop_back(v) equals: 2,
	assert: v.length equals: 2,
	assert: v elements: [0, 1],

	assert: pop_back(v) equals: 1,
	assert: v.length equals: 1,
	assert: v elements: [0],

	assert: pop_back(v) equals: 0,
	assert: v.length equals: 0,
	assert: v elements: [int] :: [],
}

// Calls f for each element of the vector,
// in order from the 0th to the (n-1)th,
// where in is the length of the vector.
Func for:each:(v T vector, f (T){}) {
	for_each(v, 0, f)
}

func for_each(v T vector, i int, f (T){}) {
	if: i >= v.length then: {
		return()
	},
	f(v[i]),
	for_each(v, i+1, f),
}
