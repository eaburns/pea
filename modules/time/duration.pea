Import "basic"

// A duration of time.
Type duration := _duration
type _duration [.ns int64]

// Fixed durations of one nanosecond, microsecond, millisecond, second, minute, and hour.
Const nanosecond := duration :: [.ns 1]
Const microsecond := duration :: 1000*nanosecond
Const millisecond := duration :: 1000*microsecond
Const second := duration :: 1000*millisecond
Const minute := duration :: 60*second
Const hour := duration :: 60*minute

// Returns the result of comparing a = b, a != b, a < b, a <= b, a > b, or a >= b.
Func =(a duration, b duration) bool { return: a.ns = b.ns }
Func !=(a duration, b duration) bool { return: a.ns != b.ns }
Func <(a duration, b duration) bool { return: a.ns < b.ns }
Func <=(a duration, b duration) bool { return: a.ns <= b.ns }
Func >(a duration, b duration) bool { return: a.ns > b.ns }
Func >=(a duration, b duration) bool { return: a.ns >= b.ns }

test duration_comparison {
	assert_true: second = second,
	assert_true: nanosecond = nanosecond,
	assert_true: 20*millisecond = 20*millisecond,
	assert_true: second = ((int64 :: 1.0e9) * nanosecond),
	assert_false: second = minute,
	assert_false: 2*minute = minute,
	assert_false: 20*nanosecond = nanosecond,
	assert_false: second = ((int64 :: 1.0e8) * nanosecond),

	assert_false: second != second,
	assert_false: nanosecond != nanosecond,
	assert_false: 20*millisecond != 20*millisecond,
	assert_false: second != ((int64 :: 1.0e9) * nanosecond),
	assert_true: second != minute,
	assert_true: 2*minute != minute,
	assert_true: 20*nanosecond != nanosecond,
	assert_true: second != ((int64 :: 1.0e8) * nanosecond),

	assert_true: millisecond < second,
	assert_true: nanosecond < millisecond,
	assert_true: nanosecond < 2*nanosecond,
	assert_true: 20*minute < 200*minute,
	assert_false: second < millisecond,
	assert_false: millisecond < nanosecond,
	assert_false: 2*nanosecond < nanosecond,
	assert_false: 200*minute < 20*minute,
	assert_false: second < second,

	assert_true: millisecond <= second,
	assert_true: nanosecond <= millisecond,
	assert_true: nanosecond <= 2*nanosecond,
	assert_true: 20*minute <= 200*minute,
	assert_false: second <= millisecond,
	assert_false: millisecond <= nanosecond,
	assert_false: 2*nanosecond <= nanosecond,
	assert_false: 200*minute <= 20*minute,
	assert_true: second <= second,

	assert_false: millisecond > second,
	assert_false: nanosecond > millisecond,
	assert_false: nanosecond > 2*nanosecond,
	assert_false: 20*minute > 200*minute,
	assert_true: second > millisecond,
	assert_true: millisecond > nanosecond,
	assert_true: 2*nanosecond > nanosecond,
	assert_true: 200*minute > 20*minute,
	assert_false: second > second,

	assert_false: millisecond >= second,
	assert_false: nanosecond >= millisecond,
	assert_false: nanosecond >= 2*nanosecond,
	assert_false: 20*minute >= 200*minute,
	assert_true: second >= millisecond,
	assert_true: millisecond >= nanosecond,
	assert_true: 2*nanosecond >= nanosecond,
	assert_true: 200*minute >= 20*minute,
	assert_true: second >= second,
}

// Returns the negation of a duration.
Func -(a duration) duration { return: [.ns -a.ns] }

test duration_negation {
	assert: -second equals: 0*second-second,
	assert: - -second equals: second,
	assert: - 500*millisecond equals: second-1500*millisecond,
}

// Returns the duration a+b or respectively a-b.
Func +(a duration, b duration) duration { return: [.ns a.ns + b.ns] }
Func -(a duration, b duration) duration { return: [.ns a.ns - b.ns] }

// Assigns a+b or respectively a-b to a.
Func +=(a &duration, b duration) { a := a + b }
Func -=(a &duration, b duration) { a := a - b }

test duration_addition {
	assert: second+second equals: 2*second,
	assert: 2*second-second equals: second,
	assert: second+(1000*millisecond) equals: 2*second,
	assert: 2*second-(1000*millisecond) equals: second,
	assert: second+(500*millisecond) equals: 1500*millisecond,
	assert: second-(500*millisecond) equals: 500*millisecond,

	x := second,
	x += second,
	assert: x equals: 2*second,

	x := second,
	x -= 500*millisecond,
	assert: x equals: 500*millisecond,
}

// Returns the duration a*b.
// These can be particularly useful with the duration unit constants.
// For example,
// 	10*time#second // a duration of 10 seconds.
Func *(a duration, b int) duration { return: a * (int64 :: b) }
Func *(a int, b duration) duration { return: (int64 :: a) * b }
Func *(a duration, b int64) duration { return: [.ns a.ns * b] }
Func *(a int64, b duration) duration { return: [.ns a * b.ns] }

test duration_multiplication {
	assert: second*(int :: 2) equals: second+second,
	assert: second*(int64 :: 2) equals: second+second,
	assert: 2*second equals: second+second,
	assert: (int64::2)*second equals: second+second,
}

// Returns the quotient a/b.
// This is useful to determine how many times one duration fits into another.
// For example:
// 	time#second / time#nanosecond // number of nanoseconds in a second.
Func /(a duration, b duration) float64 { return: (float64 :: a.ns) / (float64 :: b.ns) }

test duration_division {
	assert: minute/second equals: 60,
	assert: second/millisecond equals: 1000,
	assert: second/(500*millisecond) equals: 2,
	assert: (500*millisecond)/second equals: 0.5,
}

// Adds the string representation of the duration to the printer and returns the printer.
// Duration strings are sequences of numbers and unit suffixes.
// Unit suffixes are:
// 	"ns" for nanoseconds
// 	"μs" for microseconds
// 	"ms" for milliseconds
// 	"s" for seconds
// 	"m" for minutes
// 	"h" for hours
// For durations of less than 1 second,
// the durations is printed as a floating point representation
// of the largest unit that fits the time without a fracation, or nanoseconds.
// For durations greater than or equal to 1 second,
// the durations is printed as the integer number of hours, if non-zero,
// the integer number of minutes, if non-zero,
// and the floating point number of seconds, if non-zero.
Func +=(p printer, d duration) printer {
	if: d.ns < 0 then: {
		p += "-",
		d.ns := -d.ns
	},
	if: d < microsecond then: {
		return: p += d.ns += "ns"
	},
	if: d < millisecond then: {
		return: p += d/microsecond += "μs"
	},
	if: d < second then: {
		return: p += d/millisecond += "ms"
	},

	if: d >= hour then: {
		h := int :: d/hour,
		d -= h*hour,
		p += h += "h",
	},
	if: d >= minute then: {
		m := int :: d/minute,
		d -= m*minute,
		p += m += "m",
	},
	if: d.ns > 0 then: {
		s := int :: d/second,
		d -= s*second,
		p += s,
		if: d.ns > 0 then: {
			f := print_string(d / second),
			p += f[1,f.length], // trim leading 0.
		},
		p += "s",
	},
	return: p
}

test duration_string {
	assert: print_string(1*nanosecond) equals: "1ns",
	assert: print_string(1*microsecond) equals: "1μs",
	assert: print_string(1*millisecond) equals: "1ms",
	assert: print_string(500*millisecond + 1*nanosecond) equals: "500.000001ms",
	assert: print_string(1*second) equals: "1s",
	assert: print_string(1*minute) equals: "1m",
	assert: print_string(1*hour) equals: "1h",
	assert: print_string(2*nanosecond) equals: "2ns",
	assert: print_string(2*microsecond) equals: "2μs",
	assert: print_string(2*millisecond) equals: "2ms",
	assert: print_string(2*second) equals: "2s",
	assert: print_string(2*minute) equals: "2m",
	assert: print_string(2*hour) equals: "2h",
	assert: print_string(2*hour + 3*minute + 4*second + 500*millisecond) equals: "2h3m4.5s",
	assert: print_string(2*millisecond + 500*microsecond) equals: "2.5ms",
	assert: print_string(2*microsecond + 500*nanosecond) equals: "2.5μs",
	assert: print_string(1000000000*nanosecond) equals: "1s",
	assert: print_string(1000000*microsecond) equals: "1s",
	assert: print_string(1000*millisecond) equals: "1s",
	assert: print_string(60*second) equals: "1m",
	assert: print_string(60*minute) equals: "1h",
	assert: print_string(24*hour) equals: "24h",
	assert: print_string(36*hour) equals: "36h",
	assert: print_string(86400*second) equals: "24h",
	assert: print_string(86401*second) equals: "24h1s",
	assert: print_string(86401*second) equals: "24h1s",

	assert: print_string(-2*hour - 3*minute - 4*second - 500*millisecond) equals: "-2h3m4.5s",

	assert: print_string(5*second + 30*nanosecond) equals: "5.00000003s",
	assert: print_string(86401*second+30*nanosecond) equals: "24h1.00000003s",
}
