// An error.
Type error ([.msg string])

// Returns a new error with a given message.
Func new(msg string) error {
	return: [.msg msg]
}

// Returns the error's message.
Func message(err error) string {
	return: err.msg
}

// An error or some value of type T.
Type T or_error [error? error, ok? T]

// Returns a new or_error in the ok? case with the given T value.
Func ok(t T) T or_error {
	return: [ok? t]
}

// Returns a new or_error in the error? case with the given error value.
Func error(err error) T or_error {
	return: [error? err]
}

// Returns a new or_error in the error? case with a new error value
// that has the given message.
Func error(msg string) T or_error {
	return: [error? new(msg)]
}

// Panics if the case of o is no the error? case,
// and returns the ok? value if it is the ok? case.
Func must(o T or_error) T {
	return: o ok? (t){t} error? (e){panic(message(e))}
}

// Returns a new error option with the none? case.
Func ok() error option {
	return: none()
}

// Returns a new error option with the some? case
// containing the given error value.
Func error(e error) error option {
	return: some(e)
}

// Returns a new error option with the some? case
// containing a new error that has the given message.
Func error(msg string) error option {
	return: some(new(msg))
}

// Panics if the case of o is some?.
Func must(o error option) {
	if: o some: (e){ panic(message(e)) }
}

// Calls k() if the case of o is none?.
Func if:ok:(o error option, k (){}) {
	if: o none: k
}

// Calls e with the some? case value if the case of o is some?.
Func if:error:(o error option, e (error){}) {
	if: o some: e
}

// Calls k() if the case of o is none?,
// otherwise calls e with the some? case value.
Func if:ok:error:(o error option, k (){}, e (error){}) {
	if: o some: e none: k
}

// Calls k() if the case of o is none?,
// otherwise calls e with the some? case value.
Func if:error:ok:(o error option, e (error){}, k (){}) {
	if: o some: e none: k
}