// The maximum value of a uint32.
Const max_uint32 := uint32 :: 4294967295

// Increases the value of n by one.
Func ++(n &int) { n := n + 1 }
Func ++(n &int8) { n := n + 1 }
Func ++(n &int16) { n := n + 1 }
Func ++(n &int32) { n := n + 1 }
Func ++(n &int64) { n := n + 1 }
Func ++(n &uint) { n := n + 1 }
Func ++(n &uint8) { n := n + 1 }
Func ++(n &uint16) { n := n + 1 }
Func ++(n &uint32) { n := n + 1 }
Func ++(n &uint64) { n := n + 1 }

test int_inc {
	n := -3,
	++n,
	assert_true: n = -2,
	++n,
	assert_true: n = -1,
	++n,
	assert_true: n = 0,
	++n,
	assert_true: n = 1,
	++n,
	assert_true: n = 2,
	++n,
	assert_true: n = 3,
}

// Decreases the value of n by one.
Func --(n &int) { n := n - 1 }
Func --(n &int8) { n := n - 1 }
Func --(n &int16) { n := n - 1 }
Func --(n &int32) { n := n - 1 }
Func --(n &int64) { n := n - 1 }
Func --(n &uint) { n := n - 1 }
Func --(n &uint8) { n := n - 1 }
Func --(n &uint16) { n := n - 1 }
Func --(n &uint32) { n := n - 1 }
Func --(n &uint64) { n := n - 1 }

test int_dec {
	n := 3,
	--n,
	assert_true: n = 2,
	--n,
	assert_true: n = 1,
	--n,
	assert_true: n = 0,
	--n,
	assert_true: n = -1,
	--n,
	assert_true: n = -2,
	--n,
	assert_true: n = -3,
}

// Assigns the result of x OP y to x,
// where OP is +, -, *, /, or %,
// as denoted by the operator name.
Func +=(x &int, y int) { x := x + y }
Func +=(x &int8, y int8) { x := x + y }
Func +=(x &int16, y int16) { x := x + y }
Func +=(x &int32, y int32) { x := x + y }
Func +=(x &int64, y int64) { x := x + y }
Func +=(x &uint, y uint) { x := x + y }
Func +=(x &uint8, y uint8) { x := x + y }
Func +=(x &uint16, y uint16) { x := x + y }
Func +=(x &uint32, y uint32) { x := x + y }
Func +=(x &uint64, y uint64) { x := x + y }
Func -=(x &int, y int) { x := x - y }
Func -=(x &int8, y int8) { x := x - y }
Func -=(x &int16, y int16) { x := x - y }
Func -=(x &int32, y int32) { x := x - y }
Func -=(x &int64, y int64) { x := x - y }
Func -=(x &uint, y uint) { x := x - y }
Func -=(x &uint8, y uint8) { x := x - y }
Func -=(x &uint16, y uint16) { x := x - y }
Func -=(x &uint32, y uint32) { x := x - y }
Func -=(x &uint64, y uint64) { x := x - y }
Func *=(x &int, y int) { x := x * y }
Func *=(x &int8, y int8) { x := x * y }
Func *=(x &int16, y int16) { x := x * y }
Func *=(x &int32, y int32) { x := x * y }
Func *=(x &int64, y int64) { x := x * y }
Func *=(x &uint, y uint) { x := x * y }
Func *=(x &uint8, y uint8) { x := x * y }
Func *=(x &uint16, y uint16) { x := x * y }
Func *=(x &uint32, y uint32) { x := x * y }
Func *=(x &uint64, y uint64) { x := x * y }
Func /=(x &int, y int) { x := x / y }
Func /=(x &int8, y int8) { x := x / y }
Func /=(x &int16, y int16) { x := x / y }
Func /=(x &int32, y int32) { x := x / y }
Func /=(x &int64, y int64) { x := x / y }
Func /=(x &uint, y uint) { x := x / y }
Func /=(x &uint8, y uint8) { x := x / y }
Func /=(x &uint16, y uint16) { x := x / y }
Func /=(x &uint32, y uint32) { x := x / y }
Func /=(x &uint64, y uint64) { x := x / y }
Func %=(x &int, y int) { x := x % y }
Func %=(x &int8, y int8) { x := x % y }
Func %=(x &int16, y int16) { x := x % y }
Func %=(x &int32, y int32) { x := x % y }
Func %=(x &int64, y int64) { x := x % y }
Func %=(x &uint, y uint) { x := x % y }
Func %=(x &uint8, y uint8) { x := x % y }
Func %=(x &uint16, y uint16) { x := x % y }
Func %=(x &uint32, y uint32) { x := x % y }
Func %=(x &uint64, y uint64) { x := x % y }

test plus_equals {
	i := 3,
	i += 5,
	assert_true: i = 8,
}

test minus_equals {
	i := 3,
	i -= 5,
	assert_true: i = -2,
}

test times_equals {
	i := 3,
	i *= 5,
	assert_true: i = 15,
}

test divide_equals {
	i := 15,
	i /= 5,
	assert_true: i = 3,
}

test mod_equals {
	i := 18,
	i %= 5,
	assert_true: i = 3,
}

// Calls f with each value from start (inclusive)
// up to end (inclusive) in increasing order.
Func for:to:do:(start int, end int, f (int){}) {
	if: start <= end then: {
		f(start),
		for: start + 1 to: end do: f
	}
}

test for_to_do {
	iters := 0,
	for: 0 to: -1 do: (_){++iters},
	assert_true: iters = 0,

	iters := 0,
	for: 0 to: 0 do: (_){++iters},
	assert_true: iters = 1,

	iters := 0,
	for: 0 to: 1 do: (_){++iters},
	assert_true: iters = 2,

	iters := 0,
	for: -1 to: 1 do: (_){++iters},
	assert_true: iters = 3,

	iters := 0,
	inds := [int] :: new(11, -100),
	for: -5 to: 5 do: (i) {
		inds[iters] := i,
		++iters,
	},
	assert_true: iters = 11,
	assert_true: inds[0] = -5,
	assert_true: inds[1] = -4,
	assert_true: inds[2] = -3,
	assert_true: inds[3] = -2,
	assert_true: inds[4] = -1,
	assert_true: inds[5] = 0,
	assert_true: inds[6] = 1,
	assert_true: inds[7] = 2,
	assert_true: inds[8] = 3,
	assert_true: inds[9] = 4,
	assert_true: inds[10] = 5,
}

// Calls f with each value from start (inclusive)
// down to end (inclusive) in decreasing order.
Func for:down_to:do:(start int, end int, f (int){}) {
	if: start >= end then: {
		f(start),
		for: start -1 down_to: end do: f
	}
}

test for_down_to_do {
	iters := 0,
	for: -1 down_to: 0 do: (_){++iters},
	assert_true: iters = 0,

	iters := 0,
	for: 0 down_to: 0 do: (_){++iters},
	assert_true: iters = 1,

	iters := 0,
	for: 1 down_to: 0 do: (_){++iters},
	assert_true: iters = 2,

	iters := 0,
	for: 1 down_to: -1 do: (_){++iters},
	assert_true: iters = 3,

	iters := 0,
	inds := [int] :: new(11, -100),
	for: 5 down_to: -5 do: (i) {
		inds[iters] := i,
		++iters,
	},
	assert_true: iters = 11,
	assert_true: inds[0] = 5,
	assert_true: inds[1] = 4,
	assert_true: inds[2] = 3,
	assert_true: inds[3] = 2,
	assert_true: inds[4] = 1,
	assert_true: inds[5] = 0,
	assert_true: inds[6] = -1,
	assert_true: inds[7] = -2,
	assert_true: inds[8] = -3,
	assert_true: inds[9] = -4,
	assert_true: inds[10] = -5,
}
