// An alias for int32 for use with unicode code points.
Type rune := int32

// Increases the value of n by one.
Func ++(n &int) { n := n + 1 }
Func ++(n &int8) { n := n + 1 }
Func ++(n &int16) { n := n + 1 }
Func ++(n &int32) { n := n + 1 }
Func ++(n &int64) { n := n + 1 }
Func ++(n &uint) { n := n + 1 }
Func ++(n &uint8) { n := n + 1 }
Func ++(n &uint16) { n := n + 1 }
Func ++(n &uint32) { n := n + 1 }
Func ++(n &uint64) { n := n + 1 }

test int_inc {
	n := -3,
	++n,
	assert_true: n = -2,
	++n,
	assert_true: n = -1,
	++n,
	assert_true: n = 0,
	++n,
	assert_true: n = 1,
	++n,
	assert_true: n = 2,
	++n,
	assert_true: n = 3,
}

// Decreases the value of n by one.
Func --(n &int) { n := n - 1 }
Func --(n &int8) { n := n - 1 }
Func --(n &int16) { n := n - 1 }
Func --(n &int32) { n := n - 1 }
Func --(n &int64) { n := n - 1 }
Func --(n &uint) { n := n - 1 }
Func --(n &uint8) { n := n - 1 }
Func --(n &uint16) { n := n - 1 }
Func --(n &uint32) { n := n - 1 }
Func --(n &uint64) { n := n - 1 }

test int_dec {
	n := 3,
	--n,
	assert_true: n = 2,
	--n,
	assert_true: n = 1,
	--n,
	assert_true: n = 0,
	--n,
	assert_true: n = -1,
	--n,
	assert_true: n = -2,
	--n,
	assert_true: n = -3,
}

// Assigns the result of x OP y to x,
// where OP is |, &, ^, +, -, *, /, or %,
// as denoted by the operator name.
Func |=(x &int, y int) { x := x | y }
Func |=(x &int8, y int8) { x := x | y }
Func |=(x &int16, y int16) { x := x | y }
Func |=(x &int32, y int32) { x := x | y }
Func |=(x &int64, y int64) { x := x | y }
Func &=(x &int, y int) { x := x & y }
Func &=(x &int8, y int8) { x := x & y }
Func &=(x &int16, y int16) { x := x & y }
Func &=(x &int32, y int32) { x := x & y }
Func &=(x &int64, y int64) { x := x & y }
Func ^=(x &int, y int) { x := x ^ y }
Func ^=(x &int8, y int8) { x := x ^ y }
Func ^=(x &int16, y int16) { x := x ^ y }
Func ^=(x &int32, y int32) { x := x ^ y }
Func ^=(x &int64, y int64) { x := x ^ y }
Func +=(x &int, y int) { x := x + y }
Func +=(x &int8, y int8) { x := x + y }
Func +=(x &int16, y int16) { x := x + y }
Func +=(x &int32, y int32) { x := x + y }
Func +=(x &int64, y int64) { x := x + y }
Func +=(x &uint, y uint) { x := x + y }
Func +=(x &uint8, y uint8) { x := x + y }
Func +=(x &uint16, y uint16) { x := x + y }
Func +=(x &uint32, y uint32) { x := x + y }
Func +=(x &uint64, y uint64) { x := x + y }
Func -=(x &int, y int) { x := x - y }
Func -=(x &int8, y int8) { x := x - y }
Func -=(x &int16, y int16) { x := x - y }
Func -=(x &int32, y int32) { x := x - y }
Func -=(x &int64, y int64) { x := x - y }
Func -=(x &uint, y uint) { x := x - y }
Func -=(x &uint8, y uint8) { x := x - y }
Func -=(x &uint16, y uint16) { x := x - y }
Func -=(x &uint32, y uint32) { x := x - y }
Func -=(x &uint64, y uint64) { x := x - y }
Func *=(x &int, y int) { x := x * y }
Func *=(x &int8, y int8) { x := x * y }
Func *=(x &int16, y int16) { x := x * y }
Func *=(x &int32, y int32) { x := x * y }
Func *=(x &int64, y int64) { x := x * y }
Func *=(x &uint, y uint) { x := x * y }
Func *=(x &uint8, y uint8) { x := x * y }
Func *=(x &uint16, y uint16) { x := x * y }
Func *=(x &uint32, y uint32) { x := x * y }
Func *=(x &uint64, y uint64) { x := x * y }
Func /=(x &int, y int) { x := x / y }
Func /=(x &int8, y int8) { x := x / y }
Func /=(x &int16, y int16) { x := x / y }
Func /=(x &int32, y int32) { x := x / y }
Func /=(x &int64, y int64) { x := x / y }
Func /=(x &uint, y uint) { x := x / y }
Func /=(x &uint8, y uint8) { x := x / y }
Func /=(x &uint16, y uint16) { x := x / y }
Func /=(x &uint32, y uint32) { x := x / y }
Func /=(x &uint64, y uint64) { x := x / y }
Func %=(x &int, y int) { x := x % y }
Func %=(x &int8, y int8) { x := x % y }
Func %=(x &int16, y int16) { x := x % y }
Func %=(x &int32, y int32) { x := x % y }
Func %=(x &int64, y int64) { x := x % y }
Func %=(x &uint, y uint) { x := x % y }
Func %=(x &uint8, y uint8) { x := x % y }
Func %=(x &uint16, y uint16) { x := x % y }
Func %=(x &uint32, y uint32) { x := x % y }
Func %=(x &uint64, y uint64) { x := x % y }

test or_equals {
	i := 0x2,
	i |= 0x1,
	assert_true: i = 0x3,
}

test and_equals {
	i := 0x1,
	i &= 0x3,
	assert_true: i = 0x1,
}

test xor_equals {
	i := 0x7,
	i ^= 0x2,
	assert_true: i = 0x5,
}

test plus_equals {
	i := 3,
	i += 5,
	assert_true: i = 8,
}

test minus_equals {
	i := 3,
	i -= 5,
	assert_true: i = -2,
}

test times_equals {
	i := 3,
	i *= 5,
	assert_true: i = 15,
}

test divide_equals {
	i := 15,
	i /= 5,
	assert_true: i = 3,
}

test mod_equals {
	i := 18,
	i %= 5,
	assert_true: i = 3,
}

// Calls f with each value from start (inclusive)
// up to end (inclusive) in increasing order.
Func for:to:do:(start int, end int, f (int){}) {
	if: start <= end then: {
		f(start),
		for: start + 1 to: end do: f
	}
}

test for_to_do {
	iters := 0,
	for: 0 to: -1 do: (_){++iters},
	assert_true: iters = 0,

	iters := 0,
	for: 0 to: 0 do: (_){++iters},
	assert_true: iters = 1,

	iters := 0,
	for: 0 to: 1 do: (_){++iters},
	assert_true: iters = 2,

	iters := 0,
	for: -1 to: 1 do: (_){++iters},
	assert_true: iters = 3,

	iters := 0,
	inds := [int] :: new(11, -100),
	for: -5 to: 5 do: (i) {
		inds[iters] := i,
		++iters,
	},
	assert_true: iters = 11,
	assert_true: inds[0] = -5,
	assert_true: inds[1] = -4,
	assert_true: inds[2] = -3,
	assert_true: inds[3] = -2,
	assert_true: inds[4] = -1,
	assert_true: inds[5] = 0,
	assert_true: inds[6] = 1,
	assert_true: inds[7] = 2,
	assert_true: inds[8] = 3,
	assert_true: inds[9] = 4,
	assert_true: inds[10] = 5,
}

// Calls f with each value from start (inclusive)
// down to end (inclusive) in decreasing order.
Func for:down_to:do:(start int, end int, f (int){}) {
	if: start >= end then: {
		f(start),
		for: start -1 down_to: end do: f
	}
}

test for_down_to_do {
	iters := 0,
	for: -1 down_to: 0 do: (_){++iters},
	assert_true: iters = 0,

	iters := 0,
	for: 0 down_to: 0 do: (_){++iters},
	assert_true: iters = 1,

	iters := 0,
	for: 1 down_to: 0 do: (_){++iters},
	assert_true: iters = 2,

	iters := 0,
	for: 1 down_to: -1 do: (_){++iters},
	assert_true: iters = 3,

	iters := 0,
	inds := [int] :: new(11, -100),
	for: 5 down_to: -5 do: (i) {
		inds[iters] := i,
		++iters,
	},
	assert_true: iters = 11,
	assert_true: inds[0] = 5,
	assert_true: inds[1] = 4,
	assert_true: inds[2] = 3,
	assert_true: inds[3] = 2,
	assert_true: inds[4] = 1,
	assert_true: inds[5] = 0,
	assert_true: inds[6] = -1,
	assert_true: inds[7] = -2,
	assert_true: inds[8] = -3,
	assert_true: inds[9] = -4,
	assert_true: inds[10] = -5,
}

// Calls f with each value from start (inclusive)
// to end (inclusive) in order in increments of d.
// If d is non-negative, the values are in increasing order while start <= end.
// If d is negative, the values are in decreasing order while start >= end.
Func for:to:by:do:(start int, end int, d int, f (int){}) {
	if: d >= 0 then: {
		if: start <= end then: {
			f(start),
			for: start+d to: end by: d do: f
		}
	} else: {
		if: start >= end then: {
			f(start),
			for: start+d to: end by: d do: f
		}
	}
}

test for_to_by_do_positive {
	iters := 0,
	for: 0 to: -1 by: 5 do: (_){++iters},
	assert_true: iters = 0,

	iters := 0,
	for: 0 to: 0 by: 5 do: (_){++iters},
	assert_true: iters = 1,

	iters := 0,
	for: 0 to: 1 by: 5 do: (_){++iters},
	assert_true: iters = 1,

	iters := 0,
	for: -1 to: 1 by: 1 do: (_){++iters},
	assert_true: iters = 3,

	iters := 0,
	for: -1 to: 1 by: 2 do: (_){++iters},
	assert_true: iters = 2,

	iters := 0,
	inds := [int] :: new(11, -100),
	for: -5 to: 5 by: 2 do: (i) {
		inds[iters] := i,
		++iters,
	},
	assert_true: iters = 6,
	assert_true: inds[0] = -5,
	assert_true: inds[1] = -3,
	assert_true: inds[2] = -1,
	assert_true: inds[3] = 1,
	assert_true: inds[4] = 3,
	assert_true: inds[5] = 5,

	iters := 0,
	inds := [int] :: new(11, -100),
	for: -5 to: 5 by: 3 do: (i) {
		inds[iters] := i,
		++iters,
	},
	assert_true: iters = 4,
	assert_true: inds[0] = -5,
	assert_true: inds[1] = -2,
	assert_true: inds[2] = 1,
	assert_true: inds[3] = 4,
}

test for_to_by_do_negative {
	iters := 0,
	for: -1 to: 0 by: -5 do: (_){++iters},
	assert_true: iters = 0,

	iters := 0,
	for: 0 to: 0 by: -5 do: (_){++iters},
	assert_true: iters = 1,

	iters := 0,
	for: 1 to: 0 by: -5 do: (_){++iters},
	assert_true: iters = 1,

	iters := 0,
	for: 1 to: -1 by: -1 do: (_){++iters},
	assert_true: iters = 3,

	iters := 0,
	for: 1 to: -1 by: -2 do: (_){++iters},
	assert_true: iters = 2,

	iters := 0,
	inds := [int] :: new(11, -100),
	for: 5 to: -5 by: -2 do: (i) {
		inds[iters] := i,
		++iters,
	},
	assert_true: iters = 6,
	assert_true: inds[0] = 5,
	assert_true: inds[1] = 3,
	assert_true: inds[2] = 1,
	assert_true: inds[3] = -1,
	assert_true: inds[4] = -3,
	assert_true: inds[5] = -5,

	iters := 0,
	inds := [int] :: new(11, -100),
	for: 5 to: -5 by: -3 do: (i) {
		inds[iters] := i,
		++iters,
	},
	assert_true: iters = 4,
	assert_true: inds[0] = 5,
	assert_true: inds[1] = 2,
	assert_true: inds[2] = -1,
	assert_true: inds[3] = -4,
}

test for_to_by_do_zero {
	iters := 0,
	for: 3 to: 2 by: 0 do: (i){
		++iters
	},
	assert_true: iters = 0,

	// Test looping "forever";
	// this needs to be in a function
	// so it can return() from the loop
	// after a while.
	test_for_to_by_do_zero_forever(),
}

func test_for_to_by_do_zero_forever() {
	iters := 0,
	for: 1 to: 2 by: 0 do: (i){
		assert_true: i = 1,
		// It should run forever, but just go for 100 iterations.
		if: iters = 100 then: {
			return()
		},
		++iters
	},
	panic("impossible"),
}
