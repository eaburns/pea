/*
This is similar to alloc_in_loop.pea, but instead of using [&int] it uses [int box].

[&int] may feel awkward for those coming from other languages.
For x of type [&int], the expression
	x[0] := y
is the same as:
	z := &int :: x[0],
	z := int :: y

In other words, the value of y is assigned to the value of the reference held in x[0].
The array element itself is not changed.

To change the array element x[0] to be a reference to y, one needs to write
	&&int :: x[0] := y

The reason is that, unless you explicitly convert to a reference, references are always dereferenced to their inner-most value.

This is similar to C++:
	int& x = z;
	x = y;
Assigns the value of y to the value of z; it does not re-assign x to refer to y.

The box type, as show in this file behave more like how one may expect coming from languages with pointers. Boxes aren't automatically dereferenced, so assigning changes the box, not the value boxed.
*/

// 0123456789
func main() {
	zero := 0,
	a := [int box] :: new(10, &zero),
	for: 0 to: a.length - 1 do: (i int) {
		a[i] := &i
	},
	for: 0 to: a.length - 1 do: (i int) {
		print_int(*a[i])
	}
}

Type T box := T _box
type T _box [.val &T]
Func &(t &T) T box { return: [.val t]}
Func *(t T box) &T { return: t.val }

Func for:to:do:(start int, end int, f (int) {}) {
	start <= end ?true {
		f(start),
		for: start + 1 to: end do: f
	}
}

func print_int(_ int)