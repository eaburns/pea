/*
This header includes declarations useful for implementing Pea functions in C. Pea has no defined ABI, so this header is useful only for interfacing with Pea code generated by this Pea compiler implementation.

The PEA_FUNCX and PEA_VOID_FUNCX series of macros declare/define C implementations of Pea functions. To return from a PEA_FUNCX-defined function you must use PEA_RETURN.

From C, allowed Pea types are:
	* pea_XYZ numeric types,
	* pea_string,
	* A type defined by PEA_ARRAY(·) with a Pea type argument,
	* pea_void_func0_value — a no-return-value, 0-ary Pea function value,
	* or any C pointer, which must be declared in Pea as uintref and treated opaquely from Pea code.

Except for the pea_XYZ numeric types, all Pea types are passed by pointer to C functions. This is true even if the argument is a value argument in the Pea declaration. Note that if it is a value argument in Pea, the pointer argument in C must not outlive the C function, as it may be heap allocated.

This header file may re-define some pthread functions to intercept their calls in order to play well with the garbage collector. So this .h file should be included after pthread.h to make sure those defines are re-directed properly.
*/

#ifndef _LIBPEA_H_
#define _LIBPEA_H_

#define GC_THREADS
#include <gc.h>
#include <stdint.h>

// Definitions of built-in Pea numeric types.
typedef int8_t pea_bool;
typedef int8_t pea_ordering;
typedef int64_t pea_int;
typedef int8_t pea_int8;
typedef int16_t pea_int16;
typedef int32_t pea_int32;
typedef int64_t pea_int64;
typedef uint64_t pea_uint;
typedef uint8_t pea_uint8;
typedef uint16_t pea_uint16;
typedef uint32_t pea_uint32;
typedef uint64_t pea_uint64;
typedef uintptr_t pea_uintref;
typedef float pea_float32;
typedef double pea_float64;

// The Pea string type.
// It is always passed by pointr.
typedef struct {
	pea_int length;
	char* data;
} pea_string;

// A Pea array of element_type elements.
#define PEA_ARRAY(element_type) \
	struct { \
		pea_int length; \
		element_type* data; \
	}

// A Pea 0-ary function value that returns [.].
// The function value must be called with PEA_CALL_FUNC_VALUE.
typedef struct {
	void (*func)(void*);
	void *capture;
} pea_void_func0_value;

// Calls a pea_void_func0_value.
#define PEA_CALL_VOID_FUNC0_VALUE(f) \
	do { \
		pea_void_func0_value* ff = (f); \
		ff->func(ff->capture); \
	} while(0)

// A function signature for a C-implemented Pea function that has a return value.
//
// Example:
// 	PEA_FUNC(bool, is_even, pea_int x) {
// 		PEA_RETURN(x & 1 == 0);
// 	}
#define PEA_FUNC0(ret_type, name) \
	void name(ret_type* __pea_return)
#define PEA_FUNC1(ret_type, name, a0) \
	void name(a0, ret_type* __pea_return)
#define PEA_FUNC2(ret_type, name, a0, a1) \
	void name(a0, a1, ret_type* __pea_return)
#define PEA_FUNC3(ret_type, name, a0, a1, a2) \
	void name(a0, a1, a2, ret_type* __pea_return)
#define PEA_FUNC4(ret_type, name, a0, a1, a2, a3) \
	void name(a0, a1, a2, a3, ret_type* __pea_return)

// Returns a value x from a PEA_FUNC.
#define PEA_RETURN(x) \
	do { \
		*__pea_return = x; \
		return; \
	} while(0)

// A function signature for a C-implemented Pea function that has no return value.
#define PEA_VOID_FUNC0(name) \
	void name()
#define PEA_VOID_FUNC1(name, a0) \
	void name(a0)
#define PEA_VOID_FUNC2(name, a0, a1) \
	void name(a0, a1)
#define PEA_VOID_FUNC3(name, a0, a1, a2) \
	void name(a0, a1, a2)
#define PEA_VOID_FUNC4(name, a0, a1, a2, a3) \
	void name(a0, a1, a2, a3)

// pea_malloc returns a pointer to a new object of the given number of bytes.
// The returned pointer is owned by the garbage collector, so it should not be freed, but instead will be released once it is determined to be unreachable.
// Pointer-sized spans of the returned object will be scanned by the garbage collector for liveness checking.
void* pea_malloc(uint64_t bytes);

// pea_malloc_no_scan returns a pointer to a new object of the given number of bytes.
// The returned pointer is owned by the garbage collector, so it should not be freed, but instead will be released once it is determined to be unreachable.
// The object will not be scanned by the garbage collector, so it must not contain pointers to objects owned by the garbage collector.
void* pea_malloc_no_scan(uint64_t bytes);

// pea_register_finalizer registers fn to run when obj is collected.
// The fn function is called with obj as the first argument and data as the second.
//
// All the various caveats of when to not use finalizers apply:
// this is provided for compatibility with libraries that have explicitly managed memory.
// For example: pthread_mutex_destroy must be called before the mutex is freed or memory will leak.
void pea_register_finalizer(void* obj, void(*fn)(void*, void*), void* data);

// pea_panic_cstring prints a c-style sting and stack trace to standard output
// and aborts the program.
void pea_panic_cstring(const char* str, const char* file, int32_t line);

#endif // _LIBPEA_H_